package ch.epfl.sdp.cook4me.application

import ch.epfl.sdp.cook4me.persistence.repository.ChallengeRepository
import ch.epfl.sdp.cook4me.persistence.repository.ObjectCollectionRepository
import ch.epfl.sdp.cook4me.ui.challengeform.Challenge
import com.google.firebase.firestore.DocumentSnapshot
import com.google.firebase.firestore.FirebaseFirestoreException

private const val COLLECTION_PATH = "challenges"

class ChallengeFormService(
    private val challengeRepository: ChallengeRepository = ChallengeRepository(),
    private val objectCollectionRepository: ObjectCollectionRepository =
        ObjectCollectionRepository(objectPath = COLLECTION_PATH)
) {

    /**
     * Submits the form if it is valid, otherwise returns the error message
     * @param challenge the challenge to submit
     * @return null if the challenge is valid, the error message otherwise
     */
    suspend fun submitForm(challenge: Challenge): String? = if (challenge.isValidChallenge) {
        challengeRepository.add(challenge)
        null
    } else {
        challenge.challengeProblem
    }

    /**
     * Updates the challenge.
     * @param id the id of the challenge to update, generated by firestore upon creation
     * @param challenge the challenge to submit
     *
     * To update a challenge:
     * 1. Update the challenge locally.
     * Call either addParticipant, changeParticipantScore, changeParticipantIsVoted.
     * For example: val updatedChallenge = addParticipant(challenge, "haolong.li@epfl.ch")
     *
     * 2. Submit the update to firestore.
     * Call challengeFormService.updateChallenge(id, updatedChallenge) within a couroutine.
     * Here the id is the id created by firestore upon creation of the challenge.
     */
    suspend fun updateChallenge(id: String, challenge: Challenge) {
        try {
            challengeRepository.update(id, challenge)
        } catch (e: FirebaseFirestoreException) {
            println("Error updating challenge: ${e.message}")
        }
    }

    /*
    * Retrieves challenge with query name at the given field
    * e.g. getWithGivenField("name", "darth.vadar") will return a map
    *     of challenges with name (challenge attr.) "darth.vadar"
    * map id: the id of the challenge, map value: the challenge object
    * When nothing is found, an empty map is returned
    * */
    suspend fun getWithGivenField(field: String, query: Any): Map<String, Challenge> {
        val result = challengeRepository.getWithGivenField<Challenge>(field, query)
        return result.map { it.id to documentSnapshotToChallenge(it) }.toMap()
    }

    /*
    * To get the challenge of given id.
    * If nothing is found, null is returned
    * */
    suspend fun getChallengeWithId(id: String): Challenge? {
        val result = challengeRepository.getWithId<Challenge>(id)
        return result?.let { documentSnapshotToChallenge(it) }
    }

    /*
    * Retrieve all challenges in a Map
    * */
    suspend fun retrieveAllChallenges(): Map<String, Challenge> {
        val result = objectCollectionRepository.retrieveAllDocuments<Challenge>()
        return result.map { it.id to documentSnapshotToChallenge(it) }.toMap()
    }

    /*
    * Notes: Firebase could not serialize to java.untl.Calender, I will add an constructor in Challenge.kt
    * to construct an Challenge object from a map.
    * This function is used to convert a document snapshot to an challenge object manually.
    * Also see: Challenge.kt
    * */
    private fun documentSnapshotToChallenge(documentSnapshot: DocumentSnapshot) =
        Challenge(documentSnapshot.data ?: emptyMap())
}
